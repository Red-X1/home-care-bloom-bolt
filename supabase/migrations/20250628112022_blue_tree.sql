/*
  # Create dynamic sections and section items tables

  1. New Tables
    - `dynamic_sections`
      - `id` (bigint, primary key, auto-increment)
      - `section_name` (text, unique, not null)
      - `title` (text, not null)
      - `subtitle` (text, nullable)
      - `description` (text, nullable)
      - `background_color` (text, default '#ffffff')
      - `text_color` (text, default '#000000')
      - `position_order` (integer, default 0)
      - `is_visible` (boolean, default true)
      - `created_at` (timestamptz, default now())
      - `updated_at` (timestamptz, default now())
    
    - `section_items`
      - `id` (bigint, primary key, auto-increment)
      - `section_id` (bigint, foreign key to dynamic_sections)
      - `item_type` (text, not null)
      - `content` (jsonb, default '{}')
      - `position_order` (integer, default 0)
      - `created_at` (timestamptz, default now())
      - `updated_at` (timestamptz, default now())

  2. Security
    - Enable RLS on both tables
    - Add policies for public read access and authenticated user management
    - Add policies for section items linked to dynamic sections

  3. Indexes and Constraints
    - Unique constraint on section_name
    - Indexes for performance on commonly queried columns
    - Foreign key constraint with cascade delete
    - Triggers for automatic updated_at timestamp updates
*/

-- Create update_updated_at_column function if it doesn't exist
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Create dynamic_sections table
CREATE TABLE IF NOT EXISTS public.dynamic_sections (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    section_name text NOT NULL,
    title text NOT NULL,
    subtitle text,
    description text,
    background_color text DEFAULT '#ffffff'::text,
    text_color text DEFAULT '#000000'::text,
    position_order integer DEFAULT 0,
    is_visible boolean DEFAULT true,
    created_at timestamptz DEFAULT now(),
    updated_at timestamptz DEFAULT now()
);

-- Add unique constraint on section_name if it doesn't exist
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.table_constraints 
        WHERE constraint_name = 'dynamic_sections_section_name_key' 
        AND table_name = 'dynamic_sections'
    ) THEN
        ALTER TABLE public.dynamic_sections ADD CONSTRAINT dynamic_sections_section_name_key UNIQUE (section_name);
    END IF;
END $$;

-- Create indexes for dynamic_sections
CREATE INDEX IF NOT EXISTS idx_dynamic_sections_position_order ON public.dynamic_sections USING btree (position_order);
CREATE INDEX IF NOT EXISTS idx_dynamic_sections_is_visible ON public.dynamic_sections USING btree (is_visible);

-- Enable RLS on dynamic_sections
ALTER TABLE public.dynamic_sections ENABLE ROW LEVEL SECURITY;

-- Create policies for dynamic_sections
DROP POLICY IF EXISTS "Allow public read access to dynamic sections" ON public.dynamic_sections;
CREATE POLICY "Allow public read access to dynamic sections"
    ON public.dynamic_sections
    FOR SELECT
    TO public
    USING (true);

DROP POLICY IF EXISTS "Allow authenticated users to manage dynamic sections" ON public.dynamic_sections;
CREATE POLICY "Allow authenticated users to manage dynamic sections"
    ON public.dynamic_sections
    FOR ALL
    TO authenticated
    USING (true)
    WITH CHECK (true);

-- Create trigger for dynamic_sections updated_at
DROP TRIGGER IF EXISTS update_dynamic_sections_updated_at ON public.dynamic_sections;
CREATE TRIGGER update_dynamic_sections_updated_at
    BEFORE UPDATE ON public.dynamic_sections
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Create section_items table
CREATE TABLE IF NOT EXISTS public.section_items (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    section_id bigint NOT NULL,
    item_type text NOT NULL,
    content jsonb DEFAULT '{}'::jsonb NOT NULL,
    position_order integer DEFAULT 0,
    created_at timestamptz DEFAULT now(),
    updated_at timestamptz DEFAULT now()
);

-- Add foreign key constraint if it doesn't exist
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.table_constraints 
        WHERE constraint_name = 'section_items_section_id_fkey' 
        AND table_name = 'section_items'
    ) THEN
        ALTER TABLE public.section_items 
        ADD CONSTRAINT section_items_section_id_fkey 
        FOREIGN KEY (section_id) REFERENCES public.dynamic_sections(id) ON DELETE CASCADE;
    END IF;
END $$;

-- Create indexes for section_items
CREATE INDEX IF NOT EXISTS idx_section_items_section_id ON public.section_items USING btree (section_id);
CREATE INDEX IF NOT EXISTS idx_section_items_position_order ON public.section_items USING btree (position_order);

-- Enable RLS on section_items
ALTER TABLE public.section_items ENABLE ROW LEVEL SECURITY;

-- Create policies for section_items
DROP POLICY IF EXISTS "Allow public read access to section items" ON public.section_items;
CREATE POLICY "Allow public read access to section items"
    ON public.section_items
    FOR SELECT
    TO public
    USING (true);

DROP POLICY IF EXISTS "Allow authenticated users to manage section items" ON public.section_items;
CREATE POLICY "Allow authenticated users to manage section items"
    ON public.section_items
    FOR ALL
    TO authenticated
    USING (true)
    WITH CHECK (true);

-- Create trigger for section_items updated_at
DROP TRIGGER IF EXISTS update_section_items_updated_at ON public.section_items;
CREATE TRIGGER update_section_items_updated_at
    BEFORE UPDATE ON public.section_items
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();