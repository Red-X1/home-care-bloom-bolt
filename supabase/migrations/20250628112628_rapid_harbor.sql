-- Create or replace the update function
CREATE OR REPLACE FUNCTION public.update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- ============================================================================
-- PRODUCTS TABLE
-- ============================================================================

-- Ensure products table exists with correct structure
CREATE TABLE IF NOT EXISTS public.products (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name text,
  description text,
  price bigint,
  image text,
  category text,
  created_at timestamptz DEFAULT now()
);

-- Enable RLS on products
ALTER TABLE public.products ENABLE ROW LEVEL SECURITY;

-- Drop existing policies and recreate them
DROP POLICY IF EXISTS "Anyone can view products" ON public.products;
DROP POLICY IF EXISTS "Anyone can insert products" ON public.products;
DROP POLICY IF EXISTS "Anyone can update products" ON public.products;
DROP POLICY IF EXISTS "Anyone can delete products" ON public.products;

CREATE POLICY "Anyone can view products" 
  ON public.products 
  FOR SELECT 
  USING (true);

CREATE POLICY "Anyone can insert products" 
  ON public.products 
  FOR INSERT 
  WITH CHECK (true);

CREATE POLICY "Anyone can update products" 
  ON public.products 
  FOR UPDATE 
  USING (true);

CREATE POLICY "Anyone can delete products" 
  ON public.products 
  FOR DELETE 
  USING (true);

-- ============================================================================
-- SITE_CONTENT TABLE
-- ============================================================================

-- Ensure site_content table exists
CREATE TABLE IF NOT EXISTS public.site_content (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  section text,
  content jsonb,
  created_at timestamptz DEFAULT now()
);

-- Add unique constraint on section if it doesn't exist
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.table_constraints 
    WHERE constraint_name = 'site_content_section_key' 
    AND table_name = 'site_content'
  ) THEN
    ALTER TABLE public.site_content ADD CONSTRAINT site_content_section_key UNIQUE (section);
  END IF;
END $$;

-- Enable RLS on site_content
ALTER TABLE public.site_content ENABLE ROW LEVEL SECURITY;

-- Drop existing policies and recreate them
DROP POLICY IF EXISTS "Anyone can view site content" ON public.site_content;
DROP POLICY IF EXISTS "Anyone can insert site content" ON public.site_content;
DROP POLICY IF EXISTS "Anyone can update site content" ON public.site_content;

CREATE POLICY "Anyone can view site content" 
  ON public.site_content 
  FOR SELECT 
  USING (true);

CREATE POLICY "Anyone can insert site content" 
  ON public.site_content 
  FOR INSERT 
  WITH CHECK (true);

CREATE POLICY "Anyone can update site content" 
  ON public.site_content 
  FOR UPDATE 
  USING (true);

-- ============================================================================
-- SITE_SECTIONS TABLE
-- ============================================================================

-- Ensure site_sections table exists
CREATE TABLE IF NOT EXISTS public.site_sections (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  section_name text NOT NULL,
  content jsonb NOT NULL DEFAULT '{}',
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

-- Add unique constraint on section_name if it doesn't exist
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.table_constraints 
    WHERE constraint_name = 'site_sections_section_name_key' 
    AND table_name = 'site_sections'
  ) THEN
    ALTER TABLE public.site_sections ADD CONSTRAINT site_sections_section_name_key UNIQUE (section_name);
  END IF;
END $$;

-- Enable RLS on site_sections
ALTER TABLE public.site_sections ENABLE ROW LEVEL SECURITY;

-- Drop existing policies and recreate them
DROP POLICY IF EXISTS "Anyone can view site sections" ON public.site_sections;
DROP POLICY IF EXISTS "Anyone can insert site sections" ON public.site_sections;
DROP POLICY IF EXISTS "Anyone can update site sections" ON public.site_sections;

CREATE POLICY "Anyone can view site sections" 
  ON public.site_sections 
  FOR SELECT 
  USING (true);

CREATE POLICY "Anyone can insert site sections" 
  ON public.site_sections 
  FOR INSERT 
  WITH CHECK (true);

CREATE POLICY "Anyone can update site sections" 
  ON public.site_sections 
  FOR UPDATE 
  USING (true);

-- Add trigger for site_sections
DROP TRIGGER IF EXISTS update_site_sections_updated_at ON public.site_sections;
CREATE TRIGGER update_site_sections_updated_at
  BEFORE UPDATE ON public.site_sections
  FOR EACH ROW
  EXECUTE FUNCTION public.update_updated_at_column();

-- ============================================================================
-- DYNAMIC_SECTIONS TABLE
-- ============================================================================

-- Create dynamic_sections table with proper structure
CREATE TABLE IF NOT EXISTS public.dynamic_sections (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  section_name text NOT NULL,
  title text NOT NULL,
  subtitle text,
  description text,
  background_color text DEFAULT '#ffffff',
  text_color text DEFAULT '#000000',
  position_order integer DEFAULT 0,
  is_visible boolean DEFAULT true,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

-- Add unique constraint on section_name if it doesn't exist
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.table_constraints 
    WHERE constraint_name = 'dynamic_sections_section_name_key' 
    AND table_name = 'dynamic_sections'
  ) THEN
    ALTER TABLE public.dynamic_sections ADD CONSTRAINT dynamic_sections_section_name_key UNIQUE (section_name);
  END IF;
END $$;

-- Enable RLS on dynamic_sections
ALTER TABLE public.dynamic_sections ENABLE ROW LEVEL SECURITY;

-- Drop existing policies and recreate them
DROP POLICY IF EXISTS "Allow public read access to dynamic sections" ON public.dynamic_sections;
DROP POLICY IF EXISTS "Allow authenticated users to manage dynamic sections" ON public.dynamic_sections;
DROP POLICY IF EXISTS "Anyone can view dynamic sections" ON public.dynamic_sections;
DROP POLICY IF EXISTS "Anyone can insert dynamic sections" ON public.dynamic_sections;
DROP POLICY IF EXISTS "Anyone can update dynamic sections" ON public.dynamic_sections;
DROP POLICY IF EXISTS "Anyone can delete dynamic sections" ON public.dynamic_sections;

CREATE POLICY "Allow public read access to dynamic sections"
  ON public.dynamic_sections
  FOR SELECT
  USING (true);

CREATE POLICY "Allow authenticated users to manage dynamic sections"
  ON public.dynamic_sections
  FOR ALL
  TO authenticated
  USING (true)
  WITH CHECK (true);

-- Add indexes for dynamic_sections
CREATE INDEX IF NOT EXISTS idx_dynamic_sections_position_order ON public.dynamic_sections(position_order);
CREATE INDEX IF NOT EXISTS idx_dynamic_sections_is_visible ON public.dynamic_sections(is_visible);

-- Add trigger for dynamic_sections
DROP TRIGGER IF EXISTS update_dynamic_sections_updated_at ON public.dynamic_sections;
CREATE TRIGGER update_dynamic_sections_updated_at
  BEFORE UPDATE ON public.dynamic_sections
  FOR EACH ROW
  EXECUTE FUNCTION public.update_updated_at_column();

-- ============================================================================
-- SECTION_ITEMS TABLE
-- ============================================================================

-- Create section_items table
CREATE TABLE IF NOT EXISTS public.section_items (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  section_id bigint NOT NULL,
  item_type text NOT NULL,
  content jsonb NOT NULL DEFAULT '{}',
  position_order integer DEFAULT 0,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

-- Add foreign key constraint if it doesn't exist
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.table_constraints 
    WHERE constraint_name = 'section_items_section_id_fkey' 
    AND table_name = 'section_items'
  ) THEN
    ALTER TABLE public.section_items 
    ADD CONSTRAINT section_items_section_id_fkey 
    FOREIGN KEY (section_id) REFERENCES public.dynamic_sections(id) ON DELETE CASCADE;
  END IF;
END $$;

-- Enable RLS on section_items
ALTER TABLE public.section_items ENABLE ROW LEVEL SECURITY;

-- Drop existing policies and recreate them
DROP POLICY IF EXISTS "Allow public read access to section items" ON public.section_items;
DROP POLICY IF EXISTS "Allow authenticated users to manage section items" ON public.section_items;
DROP POLICY IF EXISTS "Anyone can view section items" ON public.section_items;
DROP POLICY IF EXISTS "Anyone can insert section items" ON public.section_items;
DROP POLICY IF EXISTS "Anyone can update section items" ON public.section_items;
DROP POLICY IF EXISTS "Anyone can delete section items" ON public.section_items;

CREATE POLICY "Allow public read access to section items"
  ON public.section_items
  FOR SELECT
  USING (true);

CREATE POLICY "Allow authenticated users to manage section items"
  ON public.section_items
  FOR ALL
  TO authenticated
  USING (true)
  WITH CHECK (true);

-- Add indexes for section_items
CREATE INDEX IF NOT EXISTS idx_section_items_section_id ON public.section_items(section_id);
CREATE INDEX IF NOT EXISTS idx_section_items_position_order ON public.section_items(position_order);

-- Add trigger for section_items
DROP TRIGGER IF EXISTS update_section_items_updated_at ON public.section_items;
CREATE TRIGGER update_section_items_updated_at
  BEFORE UPDATE ON public.section_items
  FOR EACH ROW
  EXECUTE FUNCTION public.update_updated_at_column();

-- ============================================================================
-- THEME_SETTINGS TABLE
-- ============================================================================

-- Create theme_settings table
CREATE TABLE IF NOT EXISTS public.theme_settings (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  setting_name text NOT NULL,
  setting_value jsonb NOT NULL DEFAULT '{}',
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

-- Add unique constraint on setting_name if it doesn't exist
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.table_constraints 
    WHERE constraint_name = 'theme_settings_setting_name_key' 
    AND table_name = 'theme_settings'
  ) THEN
    ALTER TABLE public.theme_settings ADD CONSTRAINT theme_settings_setting_name_key UNIQUE (setting_name);
  END IF;
END $$;

-- Enable RLS on theme_settings
ALTER TABLE public.theme_settings ENABLE ROW LEVEL SECURITY;

-- Drop existing policies and recreate them
DROP POLICY IF EXISTS "Anyone can view theme settings" ON public.theme_settings;
DROP POLICY IF EXISTS "Anyone can insert theme settings" ON public.theme_settings;
DROP POLICY IF EXISTS "Anyone can update theme settings" ON public.theme_settings;

CREATE POLICY "Anyone can view theme settings"
  ON public.theme_settings
  FOR SELECT
  USING (true);

CREATE POLICY "Anyone can insert theme settings"
  ON public.theme_settings
  FOR INSERT
  WITH CHECK (true);

CREATE POLICY "Anyone can update theme settings"
  ON public.theme_settings
  FOR UPDATE
  USING (true);

-- Add trigger for theme_settings
DROP TRIGGER IF EXISTS update_theme_settings_updated_at ON public.theme_settings;
CREATE TRIGGER update_theme_settings_updated_at
  BEFORE UPDATE ON public.theme_settings
  FOR EACH ROW
  EXECUTE FUNCTION public.update_updated_at_column();

-- ============================================================================
-- ADMIN_USERS TABLE
-- ============================================================================

-- Ensure admin_users table exists
CREATE TABLE IF NOT EXISTS public.admin_users (
  id text PRIMARY KEY DEFAULT gen_random_uuid()::text,
  email text NOT NULL,
  password_hash text NOT NULL,
  created_at timestamptz DEFAULT now()
);

-- Add unique constraint on email if it doesn't exist
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.table_constraints 
    WHERE constraint_name = 'admin_users_email_key' 
    AND table_name = 'admin_users'
  ) THEN
    ALTER TABLE public.admin_users ADD CONSTRAINT admin_users_email_key UNIQUE (email);
  END IF;
END $$;

-- Enable RLS on admin_users
ALTER TABLE public.admin_users ENABLE ROW LEVEL SECURITY;

-- Create policies for admin_users (restrictive)
DROP POLICY IF EXISTS "Admin users can view themselves" ON public.admin_users;
CREATE POLICY "Admin users can view themselves"
  ON public.admin_users
  FOR SELECT
  TO authenticated
  USING (true);

-- ============================================================================
-- INSERT DEFAULT DATA
-- ============================================================================

-- Insert default site content (using INSERT with WHERE NOT EXISTS)
INSERT INTO public.site_content (section, content)
SELECT 'footer', '{
  "companyName": "ЧИСТЫЙ ДОМ",
  "description": "Мы создаем экологически чистые средства для дома и личной гигиены.",
  "address": "г. Москва, ул. Примерная, д. 123",
  "phone": "+7 (495) 123-45-67",
  "email": "info@chistydom.ru",
  "socialLinks": []
}'::jsonb
WHERE NOT EXISTS (SELECT 1 FROM public.site_content WHERE section = 'footer');

INSERT INTO public.site_content (section, content)
SELECT 'contact', '{
  "title": "Остались вопросы?",
  "subtitle": "Свяжитесь с нами, и мы с удовольствием ответим на все ваши вопросы.",
  "address": "г. Москва, ул. Примерная, д. 123, офис 456",
  "phone": "+7 (495) 123-45-67",
  "email": "info@chistydom.ru",
  "workingHours": "Пн-Пт: 9:00 - 18:00\nСб-Вс: Выходные",
  "socialLinks": []
}'::jsonb
WHERE NOT EXISTS (SELECT 1 FROM public.site_content WHERE section = 'contact');

INSERT INTO public.site_content (section, content)
SELECT 'visibility', '{
  "hero": true,
  "about": true,
  "team": true,
  "gallery": true,
  "products": true,
  "contact": true
}'::jsonb
WHERE NOT EXISTS (SELECT 1 FROM public.site_content WHERE section = 'visibility');

-- Insert default theme settings (using INSERT with WHERE NOT EXISTS)
INSERT INTO public.theme_settings (setting_name, setting_value)
SELECT 'colors', '{
  "primary": "#0EA5E9",
  "secondary": "#64748B",
  "accent": "#EC4899",
  "background": "#FFFFFF",
  "foreground": "#1E293B",
  "muted": "#F1F5F9",
  "border": "#E2E8F0"
}'::jsonb
WHERE NOT EXISTS (SELECT 1 FROM public.theme_settings WHERE setting_name = 'colors');

INSERT INTO public.theme_settings (setting_name, setting_value)
SELECT 'theme_mode', '{"mode": "light"}'::jsonb
WHERE NOT EXISTS (SELECT 1 FROM public.theme_settings WHERE setting_name = 'theme_mode');

INSERT INTO public.theme_settings (setting_name, setting_value)
SELECT 'typography', '{
  "fontFamily": "Inter",
  "headingWeight": "600",
  "bodyWeight": "400"
}'::jsonb
WHERE NOT EXISTS (SELECT 1 FROM public.theme_settings WHERE setting_name = 'typography');

-- Insert sample products if none exist
INSERT INTO public.products (name, description, price, image, category)
SELECT * FROM (VALUES
  ('Универсальный очиститель', 'Эффективно удаляет загрязнения с любых поверхностей, не оставляя разводов. Безопасен для детей и животных.', 350, 'https://images.unsplash.com/photo-1585421514284-efb74320d472?ixlib=rb-4.0.3&auto=format&fit=crop&w=1470&q=80', 'Средства для уборки'),
  ('Средство для мытья посуды', 'Бережно очищает посуду от жира и загрязнений, сохраняя мягкость кожи рук. Содержит натуральные масла.', 280, 'https://images.unsplash.com/photo-1563453392212-326f5e854473?ixlib=rb-4.0.3&auto=format&fit=crop&w=1470&q=80', 'Средства для уборки'),
  ('Чистящее средство для ванной', 'Удаляет известковый налет и ржавчину с минимальными усилиями. Антибактериальный эффект без хлора.', 320, 'https://images.unsplash.com/photo-1527515734278-b2434f7f42b7?ixlib=rb-4.0.3&auto=format&fit=crop&w=1470&q=80', 'Средства для уборки'),
  ('Гель для стирки цветных тканей', 'Бережно очищает ткани, сохраняя яркость цветов даже после многократных стирок. Подходит для всех типов тканей.', 450, 'https://images.unsplash.com/photo-1582735689369-4fe89db7114c?ixlib=rb-4.0.3&auto=format&fit=crop&w=1470&q=80', 'Средства для стирки'),
  ('Шампунь для всех типов волос', 'Бережно очищает волосы и кожу головы, придавая объем и блеск. Без сульфатов, с натуральными экстрактами.', 420, 'https://images.unsplash.com/photo-1616394584738-fc6e612e71b9?ixlib=rb-4.0.3&auto=format&fit=crop&w=1470&q=80', 'Средства личной гигиены'),
  ('Гель для душа', 'Мягко очищает кожу, оставляя ощущение свежести и комфорта. Увлажняющий эффект и нейтральный pH.', 380, 'https://images.unsplash.com/photo-1619451683029-e3a56d2f0e7f?ixlib=rb-4.0.3&auto=format&fit=crop&w=1473&q=80', 'Средства личной гигиены')
) AS v(name, description, price, image, category)
WHERE NOT EXISTS (SELECT 1 FROM public.products LIMIT 1);

-- ============================================================================
-- ADMIN FUNCTIONS
-- ============================================================================

-- Create admin functions
CREATE OR REPLACE FUNCTION public.create_admin(user_email text, user_password text)
RETURNS text AS $$
DECLARE
  password_hash text;
  admin_id text;
BEGIN
  -- Hash the password (simple hash for demo - use proper hashing in production)
  password_hash := encode(digest(user_password, 'sha256'), 'hex');
  
  -- Generate admin ID
  admin_id := gen_random_uuid()::text;
  
  -- Insert admin user
  INSERT INTO public.admin_users (id, email, password_hash)
  VALUES (admin_id, user_email, password_hash);
  
  RETURN admin_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION public.is_admin(user_email text, user_password text)
RETURNS boolean AS $$
DECLARE
  password_hash text;
  stored_hash text;
BEGIN
  -- Hash the provided password
  password_hash := encode(digest(user_password, 'sha256'), 'hex');
  
  -- Get stored hash for the email
  SELECT admin_users.password_hash INTO stored_hash
  FROM public.admin_users
  WHERE email = user_email;
  
  -- Return true if hashes match
  RETURN (stored_hash IS NOT NULL AND stored_hash = password_hash);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create default admin user if none exists
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM public.admin_users LIMIT 1) THEN
    PERFORM public.create_admin('admin@example.com', 'admin123');
  END IF;
END $$;